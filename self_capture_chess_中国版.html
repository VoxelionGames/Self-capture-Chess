<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>允许自吃的PVP国际象棋（本地双人）</title>
  <style>
    :root{--light:#f0d9b5;--dark:#b58863;--sel:#4caf50;--check:#e53935}
    body{font-family:Segoe UI,Roboto,Arial;margin:18px;background:#fafafa;color:#111}
    h1{font-size:18px;margin:0 0 8px}
    #app{display:flex;gap:16px;align-items:flex-start}
    #board{display:grid;grid-template-columns:repeat(8,64px);grid-template-rows:repeat(8,64px);border:4px solid #333;box-shadow:0 6px 18px rgba(0,0,0,.12)}
    .cell{width:64px;height:64px;display:flex;align-items:center;justify-content:center;font-size:34px;cursor:pointer;user-select:none}
    .light{background:var(--light)}
    .dark{background:var(--dark)}
    .highlight{outline:3px solid rgba(76,175,80,.85);box-sizing:border-box}
    .lastmove{box-shadow:inset 0 0 0 3px rgba(0,0,0,.08)}
    .check{background:var(--check)!important;color:white}
    #sidebar{width:340px}
    .info{background:#fff;padding:12px;border-radius:10px;box-shadow:0 4px 12px rgba(0,0,0,.06)}
    .board-row{display:flex;gap:8px;margin-bottom:8px}
    button{padding:8px 10px;border-radius:8px;border:1px solid #ddd;background:#fff;cursor:pointer}
    #moves{height:320px;overflow:auto;margin-top:8px;background:#fff;padding:8px;border-radius:8px;border:1px solid #eee}
    .turn{font-weight:700}
    .small{font-size:12px;color:#666}
    #promotionDialog{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);background:#fff;padding:14px;border-radius:10px;box-shadow:0 10px 30px rgba(0,0,0,.2);display:none}
    #promotionDialog button{font-size:18px;margin:6px}
    footer{margin-top:14px;color:#666;font-size:13px}
    @media(max-width:880px){#app{flex-direction:column;align-items:center}#sidebar{width:100%}}
  </style>
</head>
<body>
  <h1>允许自吃的PVP 国际象棋（本地双人）</h1>
  <div id="app">
    <div id="board" aria-label="棋盘"></div>
    <div id="sidebar">
      <div class="info">
        <div>回合： <span id="turnIndicator" class="turn">White</span></div>
        <div class="small">规则说明：与国际象棋相同，但允许“自吃” —— 你可以移动到有你自己棋子的格子并把它吃掉（移除）。吃子、将军、和各种规则（王车易位、吃过路兵、升变）同样适用；如果王被吃掉，吃王的一方胜利。</div>
        <div class="board-row" style="margin-top:8px">
          <button id="newBtn">重新开始</button>
          <button id="undoBtn">悔棋</button>
        </div>
        <div id="status" style="margin-top:8px"></div>
        <div id="moves"></div>
      </div>
      <footer>
        提示：点击一个棋子再点击目标格。被允许吃掉自己的棋子（自吃）。
      </footer>
    </div>
  </div>

  <div id="promotionDialog">
    <div style="margin-bottom:8px">升变为：</div>
    <div>
      <button data-piece="q">♕</button>
      <button data-piece="r">♖</button>
      <button data-piece="b">♗</button>
      <button data-piece="n">♘</button>
    </div>
  </div>

  <script>
    // 简洁象棋实现（允许自吃）
    // 棋子表示：{type: 'p','r','n','b','q','k', color: 'w'|'b'} 或 null

    const boardEl = document.getElementById('board');
    const turnIndicator = document.getElementById('turnIndicator');
    const statusEl = document.getElementById('status');
    const movesEl = document.getElementById('moves');
    const newBtn = document.getElementById('newBtn');
    const undoBtn = document.getElementById('undoBtn');
    const promotionDialog = document.getElementById('promotionDialog');

    let board = null;
    let turn = 'w';
    let selected = null;
    let legalTargets = [];
    let history = [];
    let lastMove = null;
    let awaitingPromotion = null; // {from, to, color}

    const PIECE_UNICODE = {
      'wp':'♙','wr':'♖','wn':'♘','wb':'♗','wq':'♕','wk':'♔',
      'bp':'♟','br':'♜','bn':'♞','bb':'♝','bq':'♛','bk':'♚'
    };

    function emptyBoard(){
      const b = new Array(8).fill(null).map(()=>new Array(8).fill(null));
      return b;
    }

    function setupInitial(){
      board = emptyBoard();
      const back = ['r','n','b','q','k','b','n','r'];
      for(let i=0;i<8;i++){board[0][i]={type:back[i],color:'b'};board[1][i]={type:'p',color:'b'};board[6][i]={type:'p',color:'w'};board[7][i]={type:back[i],color:'w'}}
      turn='w'; selected=null; legalTargets=[]; history=[]; lastMove=null; awaitingPromotion=null; updateUI();
    }

    function coordToIndex(r,c){return r*8+c}
    function indexToCoord(idx){return [Math.floor(idx/8), idx%8]}

    function render(){
      boardEl.innerHTML='';
      for(let r=0;r<8;r++){
        for(let c=0;c<8;c++){
          const cell = document.createElement('div');
          cell.className = 'cell ' + (((r+c)%2)?'dark':'light');
          cell.dataset.r=r; cell.dataset.c=c;
          const p = board[r][c];
          if(p){cell.textContent = PIECE_UNICODE[p.color+p.type]} else cell.textContent='';
          if(selected && selected[0]==r && selected[1]==c) cell.classList.add('highlight');
          if(legalTargets.some(t=>t[0]==r && t[1]==c)) cell.classList.add('highlight');
          if(lastMove && ((lastMove.from[0]==r && lastMove.from[1]==c) || (lastMove.to[0]==r && lastMove.to[1]==c))) cell.classList.add('lastmove');
          // mark check
          const kingPos = findKing(turn);
          if(kingPos && r==kingPos[0] && c==kingPos[1] && isKingInCheck(turn)) cell.classList.add('check');
          cell.addEventListener('click', ()=>onCellClick(r,c));
          boardEl.appendChild(cell);
        }
      }
    }

    function updateUI(){
      render();
      turnIndicator.textContent = (turn=='w'?'White':'Black');
      movesEl.innerHTML = history.map((m,i)=>`<div>${i+1}. ${m.san||m.fromStr+'-'+m.toStr}</div>`).join('');
      const result = gameResult();
      if(result){ statusEl.innerHTML = '<b>结束：</b>'+result; } else { statusEl.innerHTML = ''; }
    }

    function onCellClick(r,c){
      const p = board[r][c];
      // if awaiting promotion, ignore clicks
      if(awaitingPromotion) return;
      if(selected){
        // try move
        const isLegal = legalTargets.some(t=>t[0]==r && t[1]==c);
        if(isLegal) doMove(selected,[r,c]);
        else{
          // select new if it is current-turn piece
          if(p && p.color==turn){ selected=[r,c]; legalTargets = generateLegalTargets(r,c); }
          else { selected=null; legalTargets=[]; }
        }
      } else {
        if(p && p.color==turn){ selected=[r,c]; legalTargets = generateLegalTargets(r,c); }
      }
      updateUI();
    }

    function cloneBoard(b){ return b.map(row=>row.map(cell=>cell?{...cell}:null)); }

    function findKing(color){
      for(let r=0;r<8;r++)for(let c=0;c<8;c++) if(board[r][c] && board[r][c].type=='k' && board[r][c].color==color) return [r,c];
      return null;
    }

    function isInside(r,c){return r>=0 && r<8 && c>=0 && c<8}

    // generate pseudo-legal moves (including self-capture) for piece at r,c
    function generatePseudoMoves(r,c, b){
      const p = b[r][c]; if(!p) return [];
      const res=[];
      const color = p.color; const dir = color=='w'?-1:1;
      if(p.type=='p'){
        // forward
        if(isInside(r+dir,c) && !b[r+dir][c]) res.push([r+dir,c]);
        // double
        if((color=='w' && r==6)||(color=='b' && r==1)){
          if(!b[r+dir][c] && !b[r+2*dir][c]) res.push([r+2*dir,c]);
        }
        // captures (allow capture own pieces)
        for(const dc of [-1,1]){
          const nr=r+dir, nc=c+dc;
          if(isInside(nr,nc) && b[nr][nc]) res.push([nr,nc]);
        }
        // en passant: we will handle outside (needs history)
      } else if(p.type=='n'){
        const deltas=[[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]];
        for(const d of deltas){const nr=r+d[0],nc=c+d[1]; if(isInside(nr,nc)) res.push([nr,nc]);}
      } else if(p.type=='b' || p.type=='r' || p.type=='q'){
        const dirs = [];
        if(p.type=='b' || p.type=='q') dirs.push([1,1],[1,-1],[-1,1],[-1,-1]);
        if(p.type=='r' || p.type=='q') dirs.push([1,0],[-1,0],[0,1],[0,-1]);
        for(const d of dirs){
          let nr=r+d[0], nc=c+d[1];
          while(isInside(nr,nc)){
            res.push([nr,nc]);
            if(b[nr][nc]) break; // can't jump over pieces
            nr+=d[0]; nc+=d[1];
          }
        }
      } else if(p.type=='k'){
        for(let dr=-1;dr<=1;dr++)for(let dc=-1;dc<=1;dc++){ if(dr==0 && dc==0) continue; const nr=r+dr,nc=c+dc; if(isInside(nr,nc)) res.push([nr,nc]); }
        // castling: check later with flags
      }
      return res;
    }

    function generateLegalTargets(r,c){
      const p = board[r][c]; if(!p || p.color!=turn) return [];
      const pseudo = generatePseudoMoves(r,c, board);
      let moves = [];
      // handle captures rule: self-capture allowed => target could be empty or any occupied
      for(const t of pseudo){ const [tr,tc] = t;
        // For pawns: forward moves must be empty unless double; we've already only added forward if empty.
        // But pseudo includes captures where occupant must exist — ensure pawn diagonal only if piece exists OR en passant
        if(p.type=='p' && Math.abs(tc-c)==1 && !board[tr][tc]){
          // possible en passant
          const ep = enPassantTarget();
          if(ep && ep[0]==tr && ep[1]==tc && board[r][tc] && board[r][tc].type=='p' && board[r][tc].color!=p.color){
            moves.push([tr,tc]);
            continue;
          }
          // allow self-capture? our pseudo added only when b[nr][nc] existed; so this is empty (so skip)
          continue;
        }
        // castling
        if(p.type=='k'){
          const castleMoves = castleTargets(r,c);
          for(const cm of castleMoves) moves.push(cm);
        }
        // otherwise include (we'll filter by king safety later)
        moves.push([tr,tc]);
      }

      // filter moves that go off-board etc
      // Now filter out moves that leave own king in check
      const legal = [];
      for(const m of moves){
        const [tr,tc]=m;
        const nb = cloneBoard(board);
        // special: en passant capture removal
        const ptype = nb[r][c].type;
        if(ptype=='p' && Math.abs(tc-c)==1 && !nb[tr][tc] && enPassantTarget() && enPassantTarget()[0]==tr && enPassantTarget()[1]==tc){
          // capture pawn behind
          nb[tr][tc] = nb[r][c]; nb[r][c]=null; nb[r][tc]=null;
        } else {
          // normal move (including self-capture)
          nb[tr][tc] = nb[r][c]; nb[r][c]=null;
        }
        // handle castling rook
        if(p.type=='k' && Math.abs(tc-c)==2){
          // king moved two squares -> castle
          if(tc>c){ nb[r][5] = nb[r][7]; nb[r][7]=null; }
          else { nb[r][3]=nb[r][0]; nb[r][0]=null; }
        }
        // if pawn promotion square
        if(ptype=='p' && (tr==0 || tr==7)){
          // treat as legal; promotion will be asked on execution
        }
        // check king exists and not in check
        const kingPos = findKingOnBoard(nb, turn);
        // Note: if player self-captures their own king, kingPos will be null -> that move is legal but results in loss (we'll allow it); but if king is null then it's a terminal capture - but is it allowed if it leaves king missing? We'll treat as legal move.
        if(kingPos){
          if(!isSquareAttackedBy(kingPos[0], kingPos[1], opposite(turn), nb)) legal.push(m);
        } else {
          // no king -> move allowed (self-capture king or accidental removal) – it's terminal but allowed
          legal.push(m);
        }
      }

      // remove duplicates
      const uniq = [];
      for(const m of legal){ if(!uniq.some(u=>u[0]==m[0]&&u[1]==m[1])) uniq.push(m); }
      return uniq;
    }

    function findKingOnBoard(b, color){ for(let r=0;r<8;r++)for(let c=0;c<8;c++) if(b[r][c] && b[r][c].type=='k' && b[r][c].color==color) return [r,c]; return null; }

    function isKingInCheck(color){
      const kp = findKing(color); if(!kp) return false; return isSquareAttackedBy(kp[0],kp[1], opposite(color), board);
    }

    function isSquareAttackedBy(tr,tc, attackerColor, b){
      // iterate over all attackerColor pieces and see if they can move to (tr,tc) ignoring king-safety and own capture restriction
      for(let r=0;r<8;r++)for(let c=0;c<8;c++){
        const p = b[r][c]; if(!p || p.color!=attackerColor) continue;
        if(p.type=='p'){
          const dir = p.color=='w'?-1:1; // pawn attacks forward-diagonals
          if(r+dir==tr && (c-1==tc || c+1==tc)) return true;
        } else if(p.type=='n'){
          const deltas=[[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]];
          for(const d of deltas) if(r+d[0]==tr && c+d[1]==tc) return true;
        } else if(p.type=='b' || p.type=='r' || p.type=='q'){
          const dirs = [];
          if(p.type=='b' || p.type=='q') dirs.push([1,1],[1,-1],[-1,1],[-1,-1]);
          if(p.type=='r' || p.type=='q') dirs.push([1,0],[-1,0],[0,1],[0,-1]);
          for(const d of dirs){ let nr=r+d[0], nc=c+d[1]; while(isInside(nr,nc)){
              if(nr==tr && nc==tc) return true;
              if(b[nr][nc]) break; nr+=d[0]; nc+=d[1];
          }}
        } else if(p.type=='k'){
          if(Math.abs(r-tr)<=1 && Math.abs(c-tc)<=1) return true;
        }
      }
      return false;
    }

    function opposite(col){return col=='w'?'b':'w'}

    function enPassantTarget(){
      // if last move was a pawn double step, return square behind it
      if(!lastMove) return null;
      const m = lastMove;
      if(m.piece=='p' && Math.abs(m.from[0]-m.to[0])==2){
        const row = (m.from[0]+m.to[0])/2; return [row,m.to[1]];
      }
      return null;
    }

    function castleTargets(r,c){
      const p = board[r][c]; if(!p || p.type!='k') return [];
      // simplified: check rook existence and that squares between are empty and not in check and king not moved and rook not moved
      const results=[];
      if((p.color=='w' && r==7)||(p.color=='b' && r==0)){
        // kingside
        if(board[r][c+1]==null && board[r][c+2]==null && board[r][c+3] && board[r][c+3].type=='r'){
          // ensure positions not attacked and king not in check
          if(!isKingInCheck(p.color) && !isSquareAttackedBy(r,c+1,opposite(p.color),board) && !isSquareAttackedBy(r,c+2,opposite(p.color),board)) results.push([r,c+2]);
        }
        // queenside
        if(board[r][c-1]==null && board[r][c-2]==null && board[r][c-3]==null && board[r][c-4] && board[r][c-4].type=='r'){
          if(!isKingInCheck(p.color) && !isSquareAttackedBy(r,c-1,opposite(p.color),board) && !isSquareAttackedBy(r,c-2,opposite(p.color),board)) results.push([r,c-2]);
        }
      }
      return results;
    }

    function doMove(from, to, promotionChoice=null){
      const [fr,fc]=from; const [tr,tc]=to;
      const piece = board[fr][fc]; if(!piece) return;
      // create move record
      const moveRecord = {from:[fr,fc],to:[tr,tc],piece:piece.type,color:piece.color, captured: board[tr][tc]?board[tr][tc]:null, fromStr:coordToStr(fr,fc), toStr:coordToStr(tr,tc)};
      // handle en passant
      if(piece.type=='p' && Math.abs(tc-fc)==1 && !board[tr][tc] && enPassantTarget() && enPassantTarget()[0]==tr && enPassantTarget()[1]==tc){
        // capture the pawn behind
        moveRecord.captured = board[fr][tc]; board[fr][tc]=null;
      }
      // move (allow self-capture)
      board[tr][tc]=board[fr][fc]; board[fr][fc]=null;
      // castle rook move
      if(piece.type=='k' && Math.abs(tc-fc)==2){ if(tc>fc){ board[tr][5]=board[tr][7]; board[tr][7]=null; } else { board[tr][3]=board[tr][0]; board[tr][0]=null; } }
      // promotion
      if(piece.type=='p' && (tr==0||tr==7)){
        if(!promotionChoice){ awaitingPromotion = {from:[fr,fc], to:[tr,tc], color:piece.color}; showPromotionDialog(); history.push(moveRecord); lastMove = moveRecord; selected=null; legalTargets=[]; turn = opposite(turn); updateUI(); return; }
        board[tr][tc].type = promotionChoice; moveRecord.promotion = promotionChoice;
      }

      history.push(moveRecord); lastMove = moveRecord; selected=null; legalTargets=[]; // toggle turn
      turn = opposite(turn);
      updateUI();

      // check for immediate game end: king capture
      const whiteKing = findKingOnBoard(board,'w'); const blackKing = findKingOnBoard(board,'b');
      if(!whiteKing || !blackKing){
        const winner = !whiteKing ? 'Black' : 'White'; statusEl.innerHTML = '<b>结束：</b>' + winner + ' 因王被吃掉获胜。';
      } else {
        // checkmate/stalemate
        const res = gameResult(); if(res) statusEl.innerHTML = '<b>结束：</b>'+res;
      }
    }

    function coordToStr(r,c){ return String.fromCharCode(97+c) + (8-r); }

    function gameResult(){
      // check if one king missing -> other wins
      const wk = findKingOnBoard(board,'w'); const bk = findKingOnBoard(board,'b');
      if(!wk) return 'Black wins (white king captured)';
      if(!bk) return 'White wins (black king captured)';
      // if current side has no legal moves => checkmate or stalemate
      // find any legal move for current turn
      for(let r=0;r<8;r++) for(let c=0;c<8;c++){
        if(board[r][c] && board[r][c].color==turn){ const lm = generateLegalTargets(r,c); if(lm.length>0) return null; }
      }
      if(isKingInCheck(turn)) return (turn=='w'?'Black':'White') + ' wins by checkmate';
      return 'Stalemate (draw)';
    }

    function showPromotionDialog(){ promotionDialog.style.display='block'; }
    function hidePromotionDialog(){ promotionDialog.style.display='none'; }

    promotionDialog.addEventListener('click',(e)=>{
      const btn = e.target.closest('button'); if(!btn) return; const p = btn.dataset.piece; if(!awaitingPromotion) return; const {from,to,color} = awaitingPromotion; awaitingPromotion = null; hidePromotionDialog(); // perform promotion with chosen piece
      // the last move record is the pending promotion record
      // find last move and assign promotion
      const lm = history.pop(); // we pushed a placeholder earlier
      // apply promotion on board
      const [tr,tc]=to; board[tr][tc].type = p; lm.promotion = p; history.push(lm); lastMove = lm; updateUI();
    });

    newBtn.addEventListener('click', ()=>{ if(confirm('重新开始？当前局势将丢失。')) setupInitial(); });
    undoBtn.addEventListener('click', ()=>{ undo(); });

    function undo(){ if(history.length==0) return; const last = history.pop(); // revert
      // rebuild board from initial and replay history
      setupInitialNoRender();
      for(const m of history){ applyMoveDirect(m); }
      lastMove = history.length?history[history.length-1]:null; turn = opposite(turn); // because we always toggled after performing moves
      updateUI();
    }

    function setupInitialNoRender(){ board = emptyBoard(); const back = ['r','n','b','q','k','b','n','r']; for(let i=0;i<8;i++){board[0][i]={type:back[i],color:'b'};board[1][i]={type:'p',color:'b'};board[6][i]={type:'p',color:'w'};board[7][i]={type:back[i],color:'w'}} }

    function applyMoveDirect(m){ // used to replay history entries
      const f = m.from, t = m.to; const piece = board[f[0]][f[1]]; board[t[0]][t[1]] = piece; board[f[0]][f[1]] = null; if(m.captured && m.captured.color && m.captured.type){ /* captured already removed */ }
      if(piece && piece.type=='k' && Math.abs(f[1]-t[1])==2){ if(t[1]>f[1]){ board[t[0]][5]=board[t[0]][7]; board[t[0]][7]=null; } else { board[t[0]][3]=board[t[0]][0]; board[t[0]][0]=null; } }
      if(m.promotion && board[t[0]][t[1]]) board[t[0]][t[1]].type = m.promotion;
    }

    function doRandomMoveForTest(){ // helper, not used
      for(let r=0;r<8;r++)for(let c=0;c<8;c++) if(board[r][c]&&board[r][c].color==turn){ const lm=generateLegalTargets(r,c); if(lm.length){ doMove([r,c],lm[0]); return; } }
    }

    // init
    setupInitial();

    // expose for debug
    window._chess = {board, generateLegalTargets, doMove, history};
  </script>
</body>
</html>
